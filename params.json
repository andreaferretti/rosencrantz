{
  "name": "Rosencrantz",
  "tagline": "A web DSL for Nim",
  "body": "# Rosencrantz\r\n\r\n![shakespeare](https://raw.githubusercontent.com/andreaferretti/rosencrantz/master/shakespeare.jpg)\r\n\r\nRosencrantz is a DSL to write web servers, inspired by [Spray](http://spray.io/)\r\nand its successor [Akka HTTP](http://doc.akka.io/docs/akka/2.4.2/scala/http/introduction.html).\r\n\r\nIt sits on top of [asynchttpserver](http://nim-lang.org/docs/asynchttpserver.html)\r\nand provides a composable way to write HTTP handlers.\r\n\r\nTable of contents\r\n-----------------\r\n\r\n<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->\r\n\r\n- [Rosencrantz](#rosencrantz)\r\n  - [Introduction](#introduction)\r\n    - [Composing handlers](#composing-handlers)\r\n    - [Starting a server](#starting-a-server)\r\n  - [Structure of the package](#structure-of-the-package)\r\n  - [An example](#an-example)\r\n  - [Basic handlers](#basic-handlers)\r\n    - [Path handling](#path-handling)\r\n    - [HTTP methods](#http-methods)\r\n    - [Failure containment](#failure-containment)\r\n  - [Working with headers](#working-with-headers)\r\n  - [Writing custom handlers](#writing-custom-handlers)\r\n  - [JSON support](#json-support)\r\n  - [Form and querystring support](#form-and-querystring-support)\r\n  - [Static file support](#static-file-support)\r\n  - [CORS support](#cors-support)\r\n  - [API stability](#api-stability)\r\n\r\n<!-- /TOC -->\r\n\r\n## Introduction\r\n\r\nThe core abstraction in Rosencrantz is the `Handler`, which is just an alias\r\nfor a `proc(req: ref Request, ctx: Context): Future[Context]`. Here `Request`\r\nis the HTTP request from `asynchttpserver`, while `Context` is a place where\r\nwe accumulate information such as:\r\n\r\n* what part of the path has been matched so far;\r\n* what headers to emit with the response;\r\n* whether the request has matched a route so far.\r\n\r\nA handler usually does one or more of the following:\r\n\r\n* filter the request, by returning `ctx.reject()` if some condition is not\r\n  satisfied;\r\n* accumulate some headers;\r\n* actually respond to the request, by calling the `complete` function or one\r\n  derived from it.\r\n\r\nRosencrantz provides many of those handlers, which are described below. For the\r\ncomplete API, check [here](http://andreaferretti.github.io/rosencrantz/rosencrantz.html).\r\n\r\n### Composing handlers\r\n\r\nThe nice thing about handlers is that they are composable. There are two ways\r\nto compose two headers `h1` and `h2`:\r\n\r\n* `h1 -> h2` (read `h1` **and** `h2`) returns a handler that passes the request\r\n  through `h1` to update the context; then, if `h1` does not reject the request,\r\n  it passes it, together with the new context, to `h2`. Think filtering first\r\n  by HTTP method, then by path.\r\n* `h1 ~ h2` (read `h1` **or** `h2`) returns a handler that passes the request\r\n  through `h1`; if it rejects the request, it tries again with `h2`. Think\r\n  matching on two alternative paths.\r\n\r\nThe combination `h1 -> h2` can also be written `h1[h2]`, which makes it nicer\r\nwhen composing many handlers one inside each other. Also remember that,\r\naccording to Nim rules, `~` has higher precedence than `->` - use parentheses\r\nif necessary to compose your handlers.\r\n\r\n### Starting a server\r\n\r\nOnce you have a handler, you can serve it using a server from `asynchttpserver`,\r\nlike this:\r\n\r\n```nim\r\nlet server = newAsyncHttpServer()\r\n\r\nwaitFor server.serve(Port(8080), handler)\r\n```\r\n\r\n## Structure of the package\r\n\r\nRosencrantz can be fully imported with just\r\n\r\n```nim\r\nimport rosencrantz\r\n```\r\n\r\nThe `rosencrantz` module just re-exports functionality from the submodules\r\n`rosencrantz/core`, `rosencrantz/handlers`, `rosencrantz/jsonsupport` and so\r\non. These modules can be imported separately. The API is available\r\n[here](http://andreaferretti.github.io/rosencrantz/rosencrantz.html).\r\n\r\n## An example\r\n\r\nThe following uses some of the predefined handlers and composes them together.\r\nWe write a small piece of a fictionary API to save and retrieve messages, and\r\nwe assume we have functions such as `getMessageById` that perform the actual\r\nbusiness logic. This should give a feel of how the DSL looks like:\r\n\r\n```nim\r\nlet handler = get[\r\n  path(\"/api/status\")[\r\n    ok(getStatus())\r\n  ] ~\r\n  pathChunk(\"/api/message\")[\r\n    accept(\"application/json\")[\r\n      intSegment(proc(id: int): auto =\r\n        let message = getMessageById(id)\r\n        ok(message)\r\n      )\r\n    ]\r\n  ]\r\n] ~ post [\r\n  path(\"/api/new-message\")[\r\n    jsonBody(proc(msg: Message): auto =\r\n      let\r\n        id = generateId()\r\n        saved = saveMessage(id, msg)\r\n      if saved: ok(id)\r\n      else: complete(Http500, \"save failed\")\r\n    )\r\n  ]\r\n]\r\n```\r\n\r\nFor more (actually working) examples, check the `tests` directory. In particular,\r\n[the server example](https://github.com/andreaferretti/rosencrantz/blob/master/tests/server.nim)\r\ntests every handler defined in Rosencrantz, while\r\n[the todo example](https://github.com/andreaferretti/rosencrantz/blob/master/tests/todo.nim)\r\nimplements a server compliant with the [TODO backend project](http://www.todobackend.com/)\r\nspecs.\r\n\r\n## Basic handlers\r\n\r\nIn order to work with Rosencrantz, you can `import rosencrantz`. If you prefer\r\na more fine-grained control, there are packages `rosencrantz/core` (which\r\ncontains the definitions common to all handlers), `rosencrantz/handlers` (for\r\nthe handlers we are about to show), and then more specialized handlers under\r\n`rosencrantz/jsonsupport`, `rosencrantz/formsupport` and so on.\r\n\r\nThe simplest handlers are:\r\n\r\n* `complete(code, body, headers)` that actually responds to the request. Here\r\n  `code` is an instance of `HttpCode` from `asynchttpserver`, `body` is a\r\n  `string` and `headers` are an instance of `StringTableRef`.\r\n* `ok(body)`, which is a specialization of `complete` for a response of `200 Ok`\r\n  with a content type of `text/plain`.\r\n* `notFound(body)`, which is a specialization of `complete` for a response of\r\n  `404 Not Found` with a content type of `text/plain`.\r\n* `body(p)` extracts the body of the request. Here `p` is a\r\n  `proc(s: string): Handler` which takes the extracted body as input and\r\n  returns a handler.\r\n* `logging(handler)` takes a handler and returns the same handler, but logs\r\n  some information when a request passes through.\r\n\r\nFor instance, a simple handler that echoes back the body of the request would\r\nlook like\r\n\r\n```nim\r\nbody(proc(s: string): auto =\r\n  ok(s)\r\n)\r\n```\r\n\r\n### Path handling\r\n\r\nThere are a few handlers to filter by path and extract path parameters:\r\n\r\n* `path(s)` filters the requests where the path is equal to `s`.\r\n* `pathChunk(s)` does the same but only for a prefix of the path. This means\r\n  that one can nest more path handlers after it, unlike `path`, that matches\r\n  and consumes the whole path.\r\n* `pathEnd(p)` extracts whatever is not matched yet of the path and passes it\r\n  to `p`. Here `p` is a `proc(s: string): Handler` that takes the final part of\r\n  the path and returns a handler.\r\n* `segment(p)`, that extracts a segment of path among two `/` signs. Here `p`\r\n  is a `proc(s: string): Handler` that takes the matched segment and return a\r\n  handler. This fails if the position is not just before a `/` sign.\r\n* `intSegment(p)`, works the same as `segment`, but extracts and parses an\r\n  integer number. It fails if the segment does not represent an integer. Here\r\n  `p` is a `proc(s: int): Handler`.\r\n\r\nFor instance, to match and extract parameters out of a route like\r\n`repeat/$msg/$n`, one would nest the above to get\r\n\r\n```nim\r\npathChunk(\"/repeat\")[\r\n  segment(proc(msg: string): auto =\r\n    intSegment(proc(n: int): auto =\r\n      someHandler\r\n    )\r\n  )\r\n]\r\n```\r\n\r\n### HTTP methods\r\n\r\nTo filter by HTTP method, one can use\r\n\r\n* `verb(m)`, where `m` is a member of the `HttpMethod` enum defined in\r\n  `rosencrantz/core`. There are corresponding specializations\r\n* `get`, `post`, `put`, `delete`, `head`, `patch`, `options`, `trace` and\r\n  `connect`\r\n\r\n### Failure containment\r\n\r\nWhen a requests falls through all routes without matching, Rosencrantz will\r\nreturn a standard response of `404 Not Found`. Similarly, whenever an\r\nexception arises, Rosencrantz will respond with `500 Server Error`.\r\n\r\nSometimes, it can be useful to have more control over failure cases. For\r\ninstance, you are able only to generate responses with type `application/json`:\r\nif the `Accept` header does not match it, you may want to return a status code\r\nof `406 Not Accepted`.\r\n\r\nOne way to do this is to put the 406 response as an alternative, like this:\r\n\r\n```nim\r\naccept(\"application/json\")[\r\n  someResponse\r\n] ~ complete(Http406, \"JSON endpoint\")\r\n```\r\n\r\nHowever, it can be more clear to use an equivalent combinators that wraps\r\nan existing handler and it returns a given failure message in case the inner\r\nhandler fails to match. For this, there is\r\n\r\n* `failWith(code, s)`, to be used like this:\r\n\r\n```nim\r\nfailWith(Http406, \"JSON endpoint\")(\r\n  accept(\"application/json\")[\r\n    someResponse\r\n  ]\r\n)\r\n```\r\n\r\n## Working with headers\r\n\r\nUnder `rosencrantz/headersupport`, there are various handlers to read HTTP\r\nheaders, filter requests by their values, or accumulate HTTP headers for the\r\nresponse.\r\n\r\n* `headers(h1, h2, ...)` adds headers for the response. Here each argument is\r\n  a tuple of two strings, which are a key/value pair.\r\n* `contentType(s)` is a specialization to emit the `Content-Type` header, so\r\n  is is equivalent to `headers((\"Content-Type\", s))`.\r\n* `readAllHeaders(p)` extract the headers as a string table. Here `p` is a\r\n  `proc(hs: HttpHeaders): Handler`.\r\n* `readHeaders(s1, p)` extracts the value of the header with key `s1` and\r\n  passes it to `p`, which is of type `proc(h1: string): Handler`. It rejects\r\n  the request if the header `s1` is not defined. There are overloads\r\n  `readHeaders(s1, s2, p)` and `readHeaders(s1, s2, s3, p)`, where `p` is a\r\n  function of two arguments (resp. three arguments). To extract more than\r\n  three headers, one can use `readAllHeaders` or nest `readHeaders` calls.\r\n* `tryReadHeaders(s1, p)` works the same as `readHeaders`, but it does not\r\n  reject the request if header `s` is missing; instead, `p` receives an empty\r\n  string as default. Again, there are overloads for two and three arguments.\r\n* `checkHeaders(h1, h2, ...)` filters the request for the header value. Here\r\n  `h1` and the other are pairs of strings, representing a key and a value. If\r\n  the request does not have the corresponding headers with these values, it\r\n  will be rejected.\r\n* `accept(mimetype)` is equivalent to `checkHeaders((\"Accept\", mimetype))`.\r\n* `addDate()` returns a handler that adds the `Date` header, formatted as\r\n  a GMT date in the [HTTP date format](https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html).\r\n\r\nFor example, if you can return a result both as JSON or XML, according to the\r\nrequest, you can do\r\n\r\n```nim\r\naccept(\"application/json\")[\r\n  contentType(\"application/json\")[\r\n    ok(someJsonValue)\r\n  ]\r\n] ~ accept(\"text/xml\")[\r\n  contentType(\"text/xml\")[\r\n    ok(someXmlValue)\r\n  ]\r\n]\r\n```\r\n\r\n## Writing custom handlers\r\n\r\nSometimes, the need arises to write handlers that perform a little more custom\r\nlogic than those shown above. For those cases, Rosencrantz provides a few\r\nprocedures and templates (under `rosencrantz/custom`) that help creating\r\nyour handlers.\r\n\r\n* `getRequest(p)`, where `p` is a `proc(req: ref Request): Handler`. This\r\n  allows you to access the whole `Request` object, and as such allows more\r\n  flexibility.\r\n* `scope` is a template that creates a local scope. It us useful when one needs\r\n  to define a few variables to write a little logic inline before returning an\r\n  actual handler.\r\n* `scopeAsync` is like scope, but allows asyncronous logic (for instance waiting\r\n  on futures) in it.\r\n* `makeHandler` is a macro that removes some boilerplate in writing a custom\r\n  handler. It accepts the body of a handler, and surrounds it with the proper\r\n  function declaration, etc.\r\n\r\nAn example of usage of `scope` is the following:\r\n\r\n```nim\r\npath(\"/using-scope\")[\r\n  scope do:\r\n    let x = \"Hello, World!\"\r\n    echo \"We are returning: \", x\r\n    return ok(x)\r\n]\r\n```\r\n\r\nAn example of usage of `scopeAsync` is the following:\r\n\r\n```nim\r\npath(\"/using-scope\")[\r\n  scopeAsync do:\r\n    let x = \"Hello, World!\"\r\n    echo \"We are returning: \", x\r\n    await sleepAsync(100)\r\n    return ok(x)\r\n]\r\n```\r\n\r\nAn example of usage of `makeHandler` is the following:\r\n\r\n```nim\r\npath(\"/custom-handler\")[\r\n  makeHandler do:\r\n    let x = \"Hello, World!\"\r\n    await req[].respond(Http200, x, {\"Content-Type\": \"text/plain;charset=utf-8\"}.newStringTable)\r\n    return ctx\r\n]\r\n```\r\n\r\nThat is expanded into something like:\r\n\r\n```nim\r\npath(\"/custom-handler\")[\r\n  proc innerProc() =\r\n    proc h(req: ref Request, ctx: Context): Future[Context] {.async.} =\r\n      let x = \"Hello, World!\"\r\n      await req[].respond(Http200, x, {\"Content-Type\": \"text/plain;charset=utf-8\"}.newStringTable)\r\n      return ctx\r\n\r\n    return h\r\n\r\n  innerProc()\r\n]\r\n```\r\n\r\nNotice that `makeHandler` is a little lower-level than other parts of\r\nRosencrantz, and requires you to know how to write a custom handler.\r\n\r\n## JSON support\r\n\r\nRosencrantz has support to parse and respond with JSON, under the\r\n`rosencrantz/jsonsupport` module. It defines two typeclasses:\r\n\r\n* a type `T` is `JsonReadable` if there is function `readFromJson(json, T): T`\r\n  where `json` is of type `JsonNode`;\r\n* a type `T` is `JsonWritable` if there is a function\r\n  `renderToJson(t: T): JsonNode`.\r\n\r\nThe module `rosencrantz/core` contains the following handlers:\r\n\r\n* `ok(j)`, where `j` is of type `JsonNode`, that will respond with a content\r\n  type of `application/json`.\r\n* `ok(t)`, where `t` has a type `T` that is `JsonWritable`, that will respond\r\n  with the JSON representation of `t` and a content type of `application/json`.\r\n* `jsonBody(p)`, where `p` is a `proc(j: JsonNode): Handler`, that extracts the\r\n  body as a `JsonNode` and passes it to `p`, failing if the body is not valid\r\n  JSON.\r\n* `jsonBody(p)`, where `p` is a `proc(t: T): Handler`, where `T` is a type that\r\n  is `JsonReadable`; it extracts the body as a `T` and passes it to `p`, failing\r\n  if the body is not valid JSON or cannot be converted to `T`.\r\n\r\n## Form and querystring support\r\n\r\nRosencrantz has support to read the body of a form, either of type\r\n`application/x-www-form-urlencoded` or multipart. It also supports\r\nparsing the querystring as `application/x-www-form-urlencoded`.\r\n\r\nThe `rosencrantz/formsupport` module defines two typeclasses:\r\n\r\n* a type `T` is `UrlDecodable` if there is function `parseFromUrl(s, T): T`\r\n  where `s` is of type `StringTableRef`;\r\n* a type `T` is `UrlMultiDecodable` if there is a function\r\n  `parseFromUrl(s, T): T` where `s` is of type `TableRef[string, seq[string]]`.\r\n\r\nThe module `rosencrantz/formsupport` defines the following handlers:\r\n\r\n* `formBody(p)` where `p` is a `proc(s: StringTableRef): Handler`. It will\r\n  parse the body as an URL-encoded form and pass the corresponding string\r\n  table to `p`, rejecting the request if the body is not parseable.\r\n* `formBody(t)` where `t` has a type `T` that is `UrlDecodable`. It will\r\n  parse the body as an URL-encoded form, convert it to `T`, and pass the\r\n  resulting object to `p`. It will reject a request if the body is not parseable\r\n  or if the conversion to `T` fails.\r\n* `formBody(p)` where `p` is a\r\n  `proc(s: TableRef[string, seq[string]]): Handler`. It will parse the body as\r\n  an URL-encoded form, accumulating repeated parameters into sequences, and pass\r\n  table to `p`, rejecting the request if the body is not parseable.\r\n* `formBody(t)` where `t` has a type `T` that is `UrlMultiDecodable`. It will\r\n  parse the body as an URL-encoded with repeated parameters form, convert it\r\n  to `T`, and pass the resulting object to `p`. It will reject a request if the\r\n  body is not parseable or if the conversion to `T` fails.\r\n\r\nThere are similar handlers to extract the querystring from a request:\r\n\r\n* `queryString(p)`, where `p` is a `proc(s: string): Handler` allows to generate\r\n  a handler from the raw querystring (not parsed into parameters yet)\r\n* `queryString(p)`, where `p` is a `proc(s: StringTableRef): Handler` allows to\r\n  generate a handler from the querystring parameters, parsed as a string table.\r\n* `queryString(t)` where `t` has a type `T` that is `UrlDecodable`; works the\r\n  same as `formBody`.\r\n* `queryString(p)`, where `p` is a\r\n  `proc(s: TableRef[string, seq[string]]): Handler` allows to generate a handler\r\n  from the querystring with repeated parameters, parsed as a table.\r\n* `queryString(t)` where `t` has a type `T` that is `UrlMultiDecodable`; works\r\n  the same as `formBody`.\r\n\r\nFinally, there is a handler to parse multipart forms. The results are\r\naccumulated inside a `MultiPart` object, which is defined by\r\n\r\n```nim\r\ntype\r\n  MultiPartFile* = object\r\n    filename*, contentType*, content*: string\r\n  MultiPart* = object\r\n    fields*: StringTableRef\r\n    files*: TableRef[string, MultiPartFile]\r\n```\r\n\r\nThe handler for multipart forms is:\r\n\r\n* `multipart(p)`, where `p` is a `proc(m: MultiPart): Handler` is handed\r\n  the result of parsing the form as multipart. In case of parsing error, an\r\n  exception is raised - you can choose whether to let it propagate it and\r\n  return a 500 error, or contain it using `failWith`.\r\n\r\n## Static file support\r\n\r\nRosencrantz has support to serve static files or directories. For now, it is\r\nlimited to small files, because it does not support streaming yet.\r\n\r\nThe module `rosencrantz/staticsupport` defines the following handlers:\r\n\r\n* `file(path)`, where `path` is either absolute or relative to the current\r\n  working directory. It will respond by serving the content of the file, if\r\n  it exists and is a simple file, or reject the request if it does not exist\r\n  or is a directory.\r\n* `dir(path)`, where `path` is either absolute or relative to the current\r\n  working directory. It will respond by taking the part of the URL\r\n  requested that is not matched yet, concatenate it to `path`, and serve the\r\n  corresponding file. Again, if the file does not exist or is a directory, the\r\n  handler will reject the request.\r\n\r\nTo make things concrete, consider the following handler:\r\n\r\n```nim\r\npath(\"/main\")[\r\n  file(\"index.html\")\r\n] ~\r\npathChunk(\"/static\")[\r\n  dir(\"public\")\r\n]\r\n```\r\n\r\nThis will server the file `index.html` when the request is for the path `/main`,\r\nand it will serve the contents of the directory `public` under the URL `static`.\r\nSo, for instance, a request for `/static/css/boostrap.css` will return the\r\ncontents of the file `./public/css/boostrap.css`.\r\n\r\nAll static handlers use the [mimetypes module](http://nim-lang.org/docs/mimetypes.html)\r\nto try to guess the correct content type depending on the file extension. This\r\nshould be usually enough; if you need more control, you can wrap a `file`\r\nhandler inside a `contentType` handler to override the content type.\r\n\r\n**Note** Due to a bug in Nim 0.14.2, the static handlers will not work on this\r\nversion. They work just fine on Nim 0.14.0 or on devel.\r\n\r\n\r\n## CORS support\r\n\r\nRosencrantz has support for [Cross-Origin requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)\r\nunder the module `rosencrantz/corssupport`.\r\n\r\nThe following are essentially helper functions to produce headers related to\r\nhandling cross-origin HTTP requests, as well as reading common headers in\r\npreflight requests. These handlers are available:\r\n\r\n* `accessControlAllowOrigin(origin)` produces the header `Access-Control-Allow-Origin`\r\n  with the provided `origin` value.\r\n* `accessControlAllowAllOrigins` produces the header `Access-Control-Allow-Origin`\r\n  with the value `*`, which amounts to accepting all origins.\r\n* `accessControlExposeHeaders(headers)` produces the header `Access-Control-Expose-Headers`,\r\n  which is used to control which headers are exposed to the client.\r\n* `accessControlMaxAge(seconds)` produces the header `Access-Control-Max-Age`,\r\n  which controls the time validity for the preflight request.\r\n* `accessControlAllowCredentials(b)`, where `b` is a boolean value, produces\r\n  the header `Access-Control-Allow-Credentials`, which is used to allow the\r\n  client to pass cookies and headers related to HTTP authentication.\r\n* `accessControlAllowMethods(methods)`, where `methods` is an openarray of\r\n  `HttpMethod`, produces the header `Access-Control-Allow-Methods`, which is\r\n  used in preflight requests to communicate which methods are allowed on the\r\n  resource.\r\n* `accessControlAllowHeaders(headers)` produces the header `Access-Control-Allow-Headers`,\r\n  which is used in the preflight request to control which headers can be added\r\n  by the client.\r\n* `accessControlAllow(origin, methods, headers)` is used in preflight requests\r\n  for the common combination of specifying the origin as well as methods and\r\n  headers accepted.\r\n* `readAccessControl(p)` is used to extract information in the preflight request\r\n  from the CORS related headers at once.\r\n  Here `p` is a `proc(origin: string, m: HttpMethod, headers: seq[string]`\r\n  that will receive the origin of the request, the desired method and the\r\n  additional headers to be provided, and will return a suitable response.\r\n\r\n## API stability\r\n\r\nWhile the basic design is not going to change, the API is not completely\r\nstable yet. It is possible that the `Context` will change to accomodate some\r\nmore information, or that it will be passed as a `ref` to handlers.\r\n\r\nAs long as you compose the handlers defined above, everything will continue to\r\nwork, but if you write your own handlers by hand, this is something to be\r\naware of.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}